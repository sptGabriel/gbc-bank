// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package ports

import (
	"sync"
)

// Ensure, that HashMock does implement Hash.
// If this is not the case, regenerate this file with moq.
var _ Hash = &HashMock{}

// HashMock is a mock implementation of Hash.
//
// 	func TestSomethingThatUsesHash(t *testing.T) {
//
// 		// make and configure a mocked Hash
// 		mockedHash := &HashMock{
// 			CompareFunc: func(hashedPassword []byte, password []byte) error {
// 				panic("mock out the Compare method")
// 			},
// 			HashFunc: func(secret *string) error {
// 				panic("mock out the Hash method")
// 			},
// 		}
//
// 		// use mockedHash in code that requires Hash
// 		// and then make assertions.
//
// 	}
type HashMock struct {
	// CompareFunc mocks the Compare method.
	CompareFunc func(hashedPassword []byte, password []byte) error

	// HashFunc mocks the Hash method.
	HashFunc func(secret *string) error

	// calls tracks calls to the methods.
	calls struct {
		// Compare holds details about calls to the Compare method.
		Compare []struct {
			// HashedPassword is the hashedPassword argument value.
			HashedPassword []byte
			// Password is the password argument value.
			Password []byte
		}
		// Hash holds details about calls to the Hash method.
		Hash []struct {
			// Secret is the secret argument value.
			Secret *string
		}
	}
	lockCompare sync.RWMutex
	lockHash    sync.RWMutex
}

// Compare calls CompareFunc.
func (mock *HashMock) Compare(hashedPassword []byte, password []byte) error {
	if mock.CompareFunc == nil {
		panic("HashMock.CompareFunc: method is nil but Hash.Compare was just called")
	}
	callInfo := struct {
		HashedPassword []byte
		Password       []byte
	}{
		HashedPassword: hashedPassword,
		Password:       password,
	}
	mock.lockCompare.Lock()
	mock.calls.Compare = append(mock.calls.Compare, callInfo)
	mock.lockCompare.Unlock()
	return mock.CompareFunc(hashedPassword, password)
}

// CompareCalls gets all the calls that were made to Compare.
// Check the length with:
//     len(mockedHash.CompareCalls())
func (mock *HashMock) CompareCalls() []struct {
	HashedPassword []byte
	Password       []byte
} {
	var calls []struct {
		HashedPassword []byte
		Password       []byte
	}
	mock.lockCompare.RLock()
	calls = mock.calls.Compare
	mock.lockCompare.RUnlock()
	return calls
}

// Hash calls HashFunc.
func (mock *HashMock) Hash(secret *string) error {
	if mock.HashFunc == nil {
		panic("HashMock.HashFunc: method is nil but Hash.Hash was just called")
	}
	callInfo := struct {
		Secret *string
	}{
		Secret: secret,
	}
	mock.lockHash.Lock()
	mock.calls.Hash = append(mock.calls.Hash, callInfo)
	mock.lockHash.Unlock()
	return mock.HashFunc(secret)
}

// HashCalls gets all the calls that were made to Hash.
// Check the length with:
//     len(mockedHash.HashCalls())
func (mock *HashMock) HashCalls() []struct {
	Secret *string
} {
	var calls []struct {
		Secret *string
	}
	mock.lockHash.RLock()
	calls = mock.calls.Hash
	mock.lockHash.RUnlock()
	return calls
}
